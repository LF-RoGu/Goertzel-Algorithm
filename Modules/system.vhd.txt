library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.MATH_REAL.ALL; -- Include this library for sqrt

entity goertzel_process is
    generic (
        N_bits : integer := 20;
        numSamples : integer := 135
    );
    Port (
        clk    : in  STD_LOGIC;
        rst    : in  STD_LOGIC;
        data   : in  STD_LOGIC_VECTOR(N_bits-1 downto 0);
        coeff  : in  STD_LOGIC_VECTOR(N_bits-1 downto 0);
        cosine : in  STD_LOGIC_VECTOR (N_bits - 1 downto 0);
        sine   : in  STD_LOGIC_VECTOR (N_bits - 1 downto 0);
        magnitude : out STD_LOGIC_VECTOR (N_bits - 1 downto 0);
        ready  : out STD_LOGIC
    );
end goertzel_process;

architecture Behavioral of goertzel_process is

    signal q0_real       : signed(N_bits - 1 downto 0) := (others => '0');
    signal q1_real       : signed(N_bits - 1 downto 0) := (others => '0');
    signal q2_real       : signed(N_bits - 1 downto 0) := (others => '0');
    signal cosine_real   : signed(N_bits - 1 downto 0) := (others => '0');
    signal sine_real     : signed(N_bits - 1 downto 0) := (others => '0');
    signal coeff_real    : signed(N_bits - 1 downto 0) := (others => '0');
    signal real_part     : signed(N_bits - 1 downto 0) := (others => '0');
    signal imag_part     : signed(N_bits - 1 downto 0) := (others => '0');
    signal magnitude_real: signed(N_bits - 1 downto 0) := (others => '0');

    signal data_s  : signed(N_bits-1 downto 0);
    constant delay_cycles : integer := 1; -- Number of cycles to delay after ready signal
begin

    -- Convert input vectors to signed
    coeff_real 	<= signed(coeff);
    data_s  	<= signed(data);

    process(clk, rst)
        variable sample_count : integer := 0;
    begin
        if rst = '1' then
            q1_real <= (others => '0');
            q2_real <= (others => '0');
            q0_real <= (others => '0');
            sample_count := 0;
            ready <= '0';
        elsif rising_edge(clk) then
          if sample_count < numSamples then
            -- Perform the Goertzel algorithm computation
            q0_real <= resize(coeff_real * q1_real - q2_real + data_s, q0_real'length);
            q2_real <= q1_real;
          	q1_real <= q0_real;
          	sample_count := sample_count + 1;
			ready <= '0';
          elsif sample_count = numSamples then
          	ready <= '1';
            -- Assign internal signals to output ports
            --q1 <= std_logic_vector(q1_sig);
            --q2 <= std_logic_vector(q2_sig);
          end if;
        end if;
    end process;
end Behavioral;
